
 add more widgets:
   - layouts
       - border (✔)
       - row (✔)
       - column (✔)
       - list (✔)
   - buttons (✔)
       - push button (✔)
       - radio buttons (✔)
       - check boxes (✔)
       - menu button - how is this different to an undecorated push button?
   - button group?
   - label (✔)
   - scroll bars (✔)
   - viewport (✔)
   - menu bar
   - menu
   - status bar
   - dialog box (✔)
       - alert (✔)
       - error
       - information
       - yes/no
       - multivalue
   - text entry
   - text box
   - horizontal separator (✔)
   - vertical separator (✔)
   - padding

add controls:
   - tree control
   - multivalue dialog box (dialog box containing other widgets)
   - file save
   - file open

Look at other toolkits, work out if there are any other controls or
widgets that could be useful.

 PRIORITIES:

--1.-- Event handling - decide how to do this, do we want something
  declarative and semantically high-level for defining event handlers
  (like DUIM) or is something basic sufficient? Basic for now.  - send
  event to topmost sheet where event occurred / send keyboard events
  to current focus.

--1.5.-- Dialogs; need some way to provide feedback without having to
 throw exceptions everywhere... keep them basic, just a new sheet
 type.

1.6. extend dialogs so they are actually useful for displaying stuff
     - alert box (✔)
     - info dialog
     - yes / no dialog

--2.-- Once event handling is in place, need to experiment with scrolling
 / overflowing a screen buffer with content / clipping etc. and work
 out how scrolling is actually going to work in tandem with
 asciimetrics handling of the screen / buffers.

--3.-- Implement scrolling. Make all border panes handle scrolling
 transparently.

4. Then - more widgets, event handling, focus, input, tab order.
      - how about having a widget that shows the event stream?

5. Menus / command tables / status bars

6. Layouts - make it pretty, make it functional

7. File explorer - local fs, archives, s3


USABILITY
=========
ACCELERATORS + MNEMONICS - for buttons and generic commands

and we need command tables or some other way to tie keys and ui to
commands.

Instead of frigging pens for different purposes, put them in the theme
definition as specific pens. Move all direct Pen instantiations into
frame.

Replace magenta with some kind of grey?

LAYOUT IMPROVEMENTS
===================

Box layouts
-----------
Should support explicit sizes for kids as well as ratios. Allow space
for explicitly specified sizes, then split remaining space over
specified ratios. If there's free space left (all specified sizes but
space remains), do what? Leave undefined for now, throw on user to
make sure it doesn't happen.
First pass: fixed sizes
Second pass: percentages

TEXT ALIGNMENT ON BUTTONS / BORDER TITLES

Label needs to support alignments and truncation.

Multiline labels

Measuring text needs to be better; len(str) might not be effective for
multibyte characters.

VISUAL FEEDBACK
===============
DEFAULTS ARE OK - BUTTONS WITH NO BORDER BY DEFAULT HAVE VISUAL STATE
THAT CAN BE UPDATED (CHECK / RADIO INDICATORS). FLAT PUSH BUTTONS WILL
COME ALONG WHEN MENU BUTTONS ARE WRITTEN, WHICH WILL NEED A COLOUR
CHANGE ON PRESS.

test / fix screen resize! See docs from asciimatics


GENERAL / CODING
================
DIFFERENT TYPES OF BORDERS

look at other stuff asciimatics does (save / restore form state etc.)
and decide if that's something that could be useful.Pretty sure it
isn't...

DOCUMENTATION - write some

USE THE SHEET TYPES ALREADY PRESENT TO BUILD CONTROLS OUT OF; E.G.,
SCROLLBAR BUTTONS SHOULD BE BUTTONS, PADDING SHOULD BE BORDER PANE,
ETC.

BORDERLAYOUT CLEAR METHOD ISN'T SETTING BACKGROUND COLOUR PROPERLY
(SEE "green" BORDER IN BASIC.PY)

Unit tests, documentation, project setup. Make it more professional,
push to gitlab. Maybe people will use it... given the chance.

Migrate everything that displays text into having a contained Label
that contains the text instead.


EVENT HANDLING
==============
need to do something about events! - see draw_next_frame() in
screen.py

event handling (button click / release) seems slow. Investigate.

click detection is really ropey. Maybe asciimatics is not reporting
them like it should?


===============================================

EXAMPLE WIDGET APP - MAKE IT SHOW ALL THE OPTIONS FOR ALL THE WIDGETS.

TIDY THE WIDGETS, DOCUMENT THE PROTOCOLS.

EVENT HANDLING - HOW MUCH IS NEEDED?
  - on_click
  - on_button_down
  - on_button_up
  - on_double_click

BUTTON LABEL ALIGNMENT - do with label

Replace button hard-coded label with label sheet, implement alignments
in that type so it doesn't need to be done all over. Use in other
places also, such as when drawing text for borders.

PUSH BUTTONS: CENTER ALIGN BY DEFAULT
RADIO + CHECK BUTTONS: LEFT ALIGN BY DEFAULT

CHANGE DRAWING METHODS, FIRSTLY TO ALWAYS TAKE COORDS FIRST AND CHANGE
DRAW TO TAKE START POSITION AS WELL AS END POSITION, AND RENAME "DRAW"
→ "DRAW_TO". FOR SHEETS THAT CLIP, CLIP TO SHEET BOUNDS THEN
TRANSFORM. FOR SHEETS THAT DO NOT CLIP, JUST DRAW ALL THE THINGS,
SOMEHOW. THINK ABOUT HOW THIS WILL WORK. - Investigate asciimatics
double buffering to see how that works. Maybe it's enough for what we
want (pretty sure it isn't)

CLIPPING IN VIEWPORTS!

OVERVIEW OF SCROLLING
=====================

Multiple components:

    - scroll bars provide ability to represent scrolled area
      proportionality (size of viewport to size of scrolled area)

Scroll bars can be displayed anywhere, and are linked to the scrolled
area by being connected to a Viewport

    - scrolled sheet

The scrolled sheet is the region that is too big to fit on the display
and that the user wants to be able to navigate to different parts of.

    - viewport

The viewport is displayed in the UI. It links the scrolled sheet and
the scroll bars. When it is drawn, it displays the contents of the
scrolled sheet that "show through" the viewport at the current time as
dictated by the values of the scrollbars.

The viewport intercepts drawing operations from its children (or made
on it directly) and calculates a bounding rectangle for the operation
in the coordinate space of the scrolling pane. These extents are used
to calculate scrollbar sizes and slug sizes.
