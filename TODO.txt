
 add more widgets
   - layouts
       - border (✔)
       - row (✔)
       - column (✔)
   - buttons (✔)
       - radio buttons (✔)
       - check boxes (✔)
       - menu button
   - button group?
   - label
   - scroll bars (✔)
   - viewport
   - menu bar
   - menu
   - status bar
   - dialog box (✔)
       - alert (✔)
       - error
       - information
       - yes/no
       - multivalue
   - text entry
   - text box
   - horizontal separator
   - vertical separator
   - padding
   - list
   - tree

 PRIORITIES:

--1.-- Event handling - decide how to do this, do we want something
  declarative and semantically high-level for defining event handlers
  (like DUIM) or is something basic sufficient? Basic for now.  - send
  event to topmost sheet where event occurred / send keyboard events
  to current focus.

--1.5.-- Dialogs; need some way to provide feedback without having to
 throw exceptions everywhere... keep them basic, just a new sheet
 type.

1.6. extend dialogs so they are actually useful for displaying stuff
     - alert box (✔)
     - info dialog
     - yes / no dialog

2. Once event handling is in place, need to experiment with scrolling
 / overflowing a screen buffer with content / clipping etc. and work
 out how scrolling is actually going to work in tandem with
 asciimetrics handling of the screen / buffers.

3. Implement scrolling. Make all border panes handle scrolling
 transparently.

4. Then - more widgets, event handling, focus, input, tab order.
      - how about having a widget that shows the event stream?

5. Menus / command tables / status bars

When a button is created, it should be possible to add an accelerator
key to some global / command map and handle that accelerator at the
frame level.

Box layouts:
Should support explicit sizes for kids as well as ratios. Allow space
for explicitly specified sizes, then split remaining space over
specified ratios. If there's free space left (all specified sizes but
space remains), do what? Leave undefined for now, throw on user to
make sure it doesn't happen.

First pass: fixed sizes
Second pass: percentages

DEFAULTS ARE OK - BUTTONS WITH NO BORDER BY DEFAULT HAVE VISUAL STATE
THAT CAN BE UPDATED (CHECK / RADIO INDICATORS). FLAT PUSH BUTTONS WILL
COME ALONG WHEN MENU BUTTONS ARE WRITTEN, WHICH WILL NEED A COLOUR
CHANGE ON PRESS.

tidying

test / fix screen resize! See docs from asciimatics

need to do something about events! - see draw_next_frame() in
screen.py

and we need command tables or some other way to tie keys and ui to
commands.

specialise "region_contains_position" for decorated buttons and other
decorated widgets... not sure quite how to do that so that border can
be ignored for mouse click location but included for other "does this
point inhabit the widget space" queries...  Note if the button was
wrapped in a spacing pane, this problem would solve itself I think...

more flexibility for borders; DOUBLE, SINGLE, SPACE, NONE... could
also combine into a spacing pane.

click detection is really ropey. Maybe asciimatics is not reporting
them like it should?

event handling (button click / release) seems slow. Investigate.

look at other stuff asciimatics does (save / restore form state etc.)
and decide if that's something that could be useful.Pretty sure it
isn't...

DOCUMENTATION - write some

TEXT ALIGNMENT ON BUTTONS / BORDER TITLES

DIFFERENT TYPES OF BORDERS

EXAMPLE WIDGET APP - MAKE IT SHOW ALL THE OPTIONS FOR ALL THE WIDGETS.

TIDY THE WIDGETS, DOCUMENT THE PROTOCOLS.

EVENT HANDLING - HOW MUCH IS NEEDED?
  - on_click
  - on_button_down
  - on_button_up
  - on_double_click

BUTTON LABEL ALIGNMENT - do with label
BUTTON EXPLICIT WIDTH

Replace button hard-coded label with label sheet, implement alignments
in that type so it doesn't need to be done all over. Use in other
places also, such as when drawing text for borders.

PUSH BUTTONS: CENTER ALIGN BY DEFAULT
RADIO + CHECK BUTTONS: LEFT ALIGN BY DEFAULT

CHANGE DRAWING METHODS, FIRSTLY TO ALWAYS TAKE COORDS FIRST AND CHANGE
DRAW TO TAKE START POSITION AS WELL AS END POSITION, AND RENAME "DRAW"
→ "DRAW_TO". FOR SHEETS THAT CLIP, CLIP TO SHEET BOUNDS THEN
TRANSFORM. FOR SHEETS THAT DO NOT CLIP, JUST DRAW ALL THE THINGS,
SOMEHOW. THINK ABOUT HOW THIS WILL WORK. - Investigate asciimatics
double buffering to see how that works. Maybe it's enough for what we
want.

Unfortunately the asciimetrics double buffer is associated with the
SCREEN, not an arbitrary REGION like we want. Perhaps it can be
repurposed, not sure. Possibly we NEED "mirrored" sheets, which have
the double buffer. For now can just put on scroll content windows,
somehow. Really don't want to be actually drawing the stuff, just
record where things should be drawn, and call drawing methods for
things that are in the visible portion of the viewport. Scrolling
needs to redo this whole calculation which is maybe not
great. Although really, how much scrolling are we going to want to do?
Track:
  - min extent
  - max extent :: for scrollbar visual
  - drawing ops + their regions
The do "region intersects region" to work out what needs drawing, and
draw that during "redraw".
