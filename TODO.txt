
Widgets:

   - layouts
       - border (✔)
       - row (✔)
       - column (✔)
       - list (✔)
   - buttons
       - push button (✔)
       - radio buttons (✔)
       - check boxes (✔)
       - menu button (✔)
   - button group (✔)
   - label (✔)
   - multi-line label
   - scroll bars (✔)
   - viewport (✔)
   - menu bar (✔)
   - menu (✔)
   - dialog box
       - alert (✔)
       - info (✔)
       - yes/no (✔)
       - multivalue
   - text entry (✔)
   - multi-line text box (✔)
   - horizontal separator (✔)
   - vertical separator (✔)
   - option box (✔)
   - combo box [needs list control]
   - padding/null pane
   - progress bar
   - status bar
   - context menu
   - split pane

add controls:

   - list control
   - tree control
   - multivalue dialog box (dialog box containing other widgets)
   - file open
   - file save
   - widget explorer - add "sheet select" mode then draw widget tree
     for selected widget

Look at other toolkits, work out if there are any other controls or
widgets that could be useful.


 PRIORITIES:

*. list control event handling and widget selection inside viewport

*. tree control

*. widget explorer

*. event handling (delayed), input

*. File explorer - local fs, archives, s3

*. create "ports" for different backends; experiment with asciimatics,
 urwid, vanilla curses.

*. menu bar / box from command table

*. identifying usages of ALT modifier


USABILITY
=========
Widgets (and dialogs) should have a "value" that can be queried -
introduce a bunch of mixin types, "ValueMixin", "FocusMixin",
"LayoutMixin", "MultipleChildMixin", "SingleChildMixin",
"CommandServerMixin"...

Dialogs are only pseudo-modal; can't interact with other components
whilst popup is up but they are still receiving events and
running. Work out how to get values out of a dialog box in this case;
it's easy when they block. So either make them block (how?) or work
out how to deal with async results.

Text edit components should support select, cut, paste

Scroll up / down / left / right line / page commands on
viewport. Might not be too easy to do if arrows already used to
navigating between widgets... could change navigate to just use TAB
and SHIFT+TAB then could use arrow keys for scrolling.

Scrolled sheet is slightly wider than expected. Could fall out
naturally once migration to LTRBs is complete. See basic.py and scroll
scroller to the SE corner; text displayed has a trailing space that
should not be there.

Document how pens work. Rethink how pens work :) - the nature of pens
just sucks at the moment. Or perhaps it's just the way popups have
been set up that sucks, I'm not sure [most pen issues are related to
trying to force specific colours on widgets that are not in a common
hierarchy with other widgets that they need to share a colour scheme
with. Usually this happens between "some widget" and "some popup menu
created from that widget"]

Accelerators - if transient window is open and accelerator is used
that is not mapped in that transient window, then the main frame
should be queried to see if the accelerator exists. If it does the
transient should be closed and the accelerator widget activated
instead.  - OR - Alternatively - disable other accelerators if popup
is on screen. This might not be efficient. *MAYBE* this "rule" should
only be applied to popup transients, not dialogs? Hrm.

Adding accelerators for 0-9 would add another 10 but would need a
different way to display them. If taking this approach could also use
$%^&* etc. as accelerators...

When placing a transient window on screen (dialog / popup) the current
focus should be cached and focus returned to it when the transient
window is closed.
As part of the focus handling changes, need to properly implement
graft / attach / detach along with events or NOTE-* methods.


LAYOUT IMPROVEMENTS
===================
TEXT ALIGNMENT and truncation ON BORDER TITLES

Measuring text needs to be better; len(str) might not be effective for
multibyte characters. Need to try a few and see what breaks.

Widgets need a "fill" initarg to indicate if their preferred size
should be FILL rather than an explicit preferred size. Some layouts /
parents will want the widgets to take all available space, and some
won't. Also - spacing / padding / null sheets to take excess space.

Move drawing ops to use LTRB regions where appropriate instead of
separate coord + width, height.

Could use a tool that displays selected widgets in a layout that can
have its size set, and see how different sized containers allocate and
render different widget types.


VISUAL FEEDBACK
===============
test / fix screen resize! See docs from asciimatics

When moving up / down lines in text area if move from longer line to
shorter line to empty line, cursor is drawn at negative offset when
reach empty line - add "max(insertion_point|text_offset, 0)"
somewhere.

If list control contains decorated buttons the button just being
scrolled out of view at the top is not rendering properly.

If slug size is too small (large scrolled sheet size relative to
viewport) it disappears altogether. Fix minimum slug size to 1.

Buttons not drawing dropshadow properly (rhs missing)

Scroller is too wide - scroll bar extents / slug size not correct.

If a button is "pressed" and then receives the focus (due to shoddy
mouse event handling), need to clear the "pressed" state of the button
(without activating the button).


List Control
============

Decide what it means to "activate" a list control [focus first or most
recent focus in list control; do nothing if nothing can be focused in
the control]

up / down arrow should move focus to different list items.

currently focused item should scroll into view if outside current
visible range.

if focus is moved off list box and then returned to it, focus should
return to previously focused list item.

ESC should move focus to next focus widget AT SAME LEVEL as list
control (see text entry widgets)

scroll extents not quite right and might be easier to debug in list
control than in general viewport.

pg_up / pg_down should move focus (and scroll offset) accordingly.

TAB should maybe move focus at the level higher; should not tab
throught the list, can use arrow keys / ctrl-n, ctrl-p for that.
Maybe that's what "tab_stop" should be for? Ditto shift-TAB.

Most of the keyboard navigation in the listcontrol should be moved to
the listlayout. Then they would also work in button boxes etc. Might
also want to move a bunch off the menu box, if the listlayout
implements them. Look at hierarchy and work out where the command
tables need to be. ACTUALLY - should NOT be on listlayout because if
used at the top level just to lay things out in a column the nav
should not work the way it works when its used as an embedded widget.

Identify which other sheet types should be "tab stops" (rename to
"focus delegators"?) - tab navigation won't work within them, but
arrows / ctrl-n / ctrl-p should still work. Potential candidates:
menuboxes, buttonboxes?


GENERAL / CODING
================
DIFFERENT TYPES OF BORDERS

Use Python's "hasattr()" instead of testing if val is None where
pertinent.

Should button box have similar motion commands to list controls / menu
boxes?

Add some error types:

  - NotAttachedError

Add region.py file to geometry to put common region methods in?

DOCUMENTATION - write some (more)

USE THE SHEET TYPES ALREADY PRESENT TO BUILD CONTROLS OUT OF; E.G.,
SCROLLBAR BUTTONS SHOULD BE BUTTONS, PADDING SHOULD BE BORDER PANE,
ETC.
In order to implement this for scroll bar buttons at least, the button
labels must be able to shrink to 1x1

Unit tests, documentation, project setup.

Migrate everything that displays text into having a contained Label
that holds the text instead.

If label shrinks too much it gives up trying to display in a reduced
space. Should either prevent resize below the minimum space, or allow
the label to shrink to nothing.


EVENT HANDLING
==============
event handling (button click / release) seems slow. Investigate.

click detection is really ropey. Maybe asciimatics is not reporting
them like it should?

Implement a "functional event" that allows functions to be called at a
later point in time, after the current event is dealt with.

Can the widgets be based on urwid instead of asciimatics? Not sure if
that will make a difference to anything, might be worth trying.

Change "find_next_focus" and "find_prev_focus" methods so they wrap
instead of stopping at end of sheet hierarchy.


===============================================

EXAMPLE WIDGET APP - MAKE IT SHOW ALL THE OPTIONS FOR ALL THE WIDGETS.

TIDY THE WIDGETS, DOCUMENT THE PROTOCOLS.

EVENT HANDLING - HOW MUCH IS NEEDED?
  - on_click
  - on_double_click
  - on_activate
  - focus_in
  - focus_out

Key events go to frame, then frame focus, and ascend to parents and
finally back to the frame. Maybe should go to focus directly first?

Focus is chosen one of 3 ways:

   1. highest z-order widget that accepts focus on initial walk
   2. mouse click on widget that accepts focus
   3. keyboard navigation to widget that accepts focus

Is "focus widget" different to "selected widget"? Is it possible to
tab to a widget that does NOT accept focus? Probably not... "selected"
and "focused" are the same thing.

Is "pressed" feedback needed? Maybe but can be subtler than it is
currently.
